<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Gen (gen.Gen)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">gen</a> &#x00BB; Gen</nav><header class="odoc-preamble"><h1>Module <code><span>Gen</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#generators">Generators</a><ul><li><a href="#global-type-declarations">Global type declarations</a></li><li><a href="#transient-generators">Transient generators</a></li><li><a href="#restartable-generators">Restartable generators</a></li><li><a href="#utils">Utils</a></li><li><a href="#basic-io">Basic IO</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="generators"><a href="#generators" class="anchor"></a>Generators</h2><p>Values of type <code>'a Gen.t</code> represent a possibly infinite sequence of values of type 'a. One can only iterate once on the sequence, as it is consumed by iteration/deconstruction/access. <code>None</code> is returned when the generator is exhausted.</p><p>The submodule <a href="Restart/index.html"><code>Restart</code></a> provides utilities to work with <b>restartable generators</b>, that is, functions <code>unit -&gt; 'a Gen.t</code> that allow to build as many generators from the same source as needed.</p><h3 id="global-type-declarations"><a href="#global-type-declarations" class="anchor"></a>Global type declarations</h3><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>A generator may be called several times, yielding the next value each time. It returns <code>None</code> when no elements remain</p></div></div><div class="odoc-spec"><div class="spec type" id="type-gen" class="anchored"><a href="#type-gen" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a gen</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-S" class="anchored"><a href="#module-type-S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> S</span><span> = <a href="../Gen_intf/module-type-S/index.html">Gen_intf.S</a></span></code></div></div><h3 id="transient-generators"><a href="#transient-generators" class="anchor"></a>Transient generators</h3><div class="odoc-spec"><div class="spec value" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>Get the next value</p></div></div><div class="odoc-spec"><div class="spec value" id="val-next" class="anchored"><a href="#val-next" class="anchor"></a><code><span><span class="keyword">val</span> next : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>Synonym for <a href="#val-get"><code>get</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_exn" class="anchored"><a href="#val-get_exn" class="anchor"></a><code><span><span class="keyword">val</span> get_exn : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Get the next value, or fails</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if no element remains</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-junk" class="anchored"><a href="#val-junk" class="anchor"></a><code><span><span class="keyword">val</span> junk : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Drop the next value, discarding it.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-repeatedly" class="anchored"><a href="#val-repeatedly" class="anchor"></a><code><span><span class="keyword">val</span> repeatedly : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Call the same function an infinite number of times (useful for instance if the function is a random generator).</p></div></div><div class="odoc-include"><div class="spec-doc"><p>Operations on <b>transient</b> generators</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../Gen_intf/module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../Gen_intf/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Empty generator, with no elements</p></div></div><div class="odoc-spec"><div class="spec value" id="val-singleton" class="anchored"><a href="#val-singleton" class="anchor"></a><code><span><span class="keyword">val</span> singleton : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>One-element generator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Alias to <a href="#val-singleton"><code>singleton</code></a></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-repeat" class="anchored"><a href="#val-repeat" class="anchor"></a><code><span><span class="keyword">val</span> repeat : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Repeat same element endlessly</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iterate" class="anchored"><a href="#val-iterate" class="anchor"></a><code><span><span class="keyword">val</span> iterate : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p><code>iterate x f</code> is <code>[x; f x; f (f x); f (f (f x)); ...]</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold" class="anchored"><a href="#val-unfold" class="anchor"></a><code><span><span class="keyword">val</span> unfold : <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Dual of <a href="#val-fold"><code>fold</code></a>, with a deconstructing operation. It keeps on unfolding the <code>'b</code> value into a new <code>'b</code>, and a <code>'a</code> which is yielded, until <code>None</code> is returned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span>?limit:int <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Calls the function, starting from 0, on increasing indices. If <code>limit</code> is provided and is a positive int, iteration will stop at the limit (excluded). For instance <code>init ~limit:4 id</code> will yield 0, 1, 2, and 3.</p></div></div><h3 id="basic-combinators"><a href="#basic-combinators" class="anchor"></a>Basic combinators</h3><p><b>Note</b>: those combinators, applied to generators (not restartable generators) <i>consume</i> their argument. Sometimes they consume it lazily, sometimes eagerly, but in any case once <code>f gen</code> has been called (with <code>f</code> a combinator), <code>gen</code> shouldn't be used anymore.</p><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">_</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check whether the gen is empty. Pops an element, if any</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Fold on the generator, tail-recursively. Consumes the generator.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reduce" class="anchored"><a href="#val-reduce" class="anchor"></a><code><span><span class="keyword">val</span> reduce : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Fold on non-empty sequences. Consumes the generator.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on an empty gen</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-scan" class="anchored"><a href="#val-scan" class="anchor"></a><code><span><span class="keyword">val</span> scan : <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Like <a href="#val-fold"><code>fold</code></a>, but keeping successive values of the accumulator. Consumes the generator.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold_scan" class="anchored"><a href="#val-unfold_scan" class="anchor"></a><code><span><span class="keyword">val</span> unfold_scan : <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> * <span class="type-var">'c</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>A mix of <a href="#val-unfold"><code>unfold</code></a> and <a href="#val-scan"><code>scan</code></a>. The current state is combined with the current element to produce a new state, and an output value of type 'c.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Iterate on the gen, consumes it.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Iterate on elements with their index in the gen, from 0, consuming it.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">_</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Length of an gen (linear time), consuming it</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Lazy map. No iteration is performed now, the function will be called when the result is traversed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Lazy map with indexing starting from 0. No iteration is performed now, the function will be called when the result is traversed.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_map" class="anchored"><a href="#val-fold_map" class="anchor"></a><code><span><span class="keyword">val</span> fold_map : <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Lazy fold and map. No iteration is performed now, the function will be called when the result is traversed. The result is an iterator over the successive states of the fold.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Append the two gens; the result contains the elements of the first, then the elements of the second gen.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flatten" class="anchored"><a href="#val-flatten" class="anchor"></a><code><span><span class="keyword">val</span> flatten : <span><span><span><span class="type-var">'a</span> <a href="../Gen_intf/index.html#type-gen">Gen_intf.gen</a></span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Flatten the generator of generators</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flat_map" class="anchored"><a href="#val-flat_map" class="anchor"></a><code><span><span class="keyword">val</span> flat_map : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Gen_intf/index.html#type-gen">Gen_intf.gen</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Monadic bind; each element is transformed to a sub-gen which is then iterated on, before the next element is processed, and so on.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem" class="anchored"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span>?eq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Is the given element, member of the gen?</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Take at most n elements</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop" class="anchored"><a href="#val-drop" class="anchor"></a><code><span><span class="keyword">val</span> drop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Drop n elements</p></div></div><div class="odoc-spec"><div class="spec value" id="val-nth" class="anchored"><a href="#val-nth" class="anchor"></a><code><span><span class="keyword">val</span> nth : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>n-th element, or Not_found</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if the generator contains less than <code>n</code> arguments</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-take_nth" class="anchored"><a href="#val-take_nth" class="anchor"></a><code><span><span class="keyword">val</span> take_nth : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p><code>take_nth n g</code> returns every element of <code>g</code> whose index is a multiple of <code>n</code>. For instance <code>take_nth 2 (1--10) |&gt; to_list</code> will return <code>1;3;5;7;9</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Filter out elements that do not satisfy the predicate.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span><span class="keyword">val</span> take_while : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Take elements while they satisfy the predicate. The initial generator itself is not to be used anymore after this.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_while" class="anchored"><a href="#val-fold_while" class="anchor"></a><code><span><span class="keyword">val</span> fold_while : 
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span>[ `Stop <span>| `Continue</span> ]</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Fold elements until (<code>'a, `Stop</code>) is indicated by the accumulator.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_while" class="anchored"><a href="#val-drop_while" class="anchor"></a><code><span><span class="keyword">val</span> drop_while : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Drop elements while they satisfy the predicate. The initial generator itself should not be used anymore, only the result of <code>drop_while</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Maps some elements to 'b, drop the other ones</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zip_index" class="anchored"><a href="#val-zip_index" class="anchor"></a><code><span><span class="keyword">val</span> zip_index : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * <span class="type-var">'a</span>)</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Zip elements with their index in the gen</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unzip" class="anchored"><a href="#val-unzip" class="anchor"></a><code><span><span class="keyword">val</span> unzip : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> * <span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Unzip into two sequences, splitting each pair</p></div></div><div class="odoc-spec"><div class="spec value" id="val-partition" class="anchored"><a href="#val-partition" class="anchor"></a><code><span><span class="keyword">val</span> partition : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> * <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p><code>partition p l</code> returns the elements that satisfy <code>p</code>, and the elements that do not satisfy <code>p</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Is the predicate true for all elements?</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Is the predicate true for at least one element?</p></div></div><div class="odoc-spec"><div class="spec value" id="val-min" class="anchored"><a href="#val-min" class="anchor"></a><code><span><span class="keyword">val</span> min : <span>?lt:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Minimum element, according to the given comparison function.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the generator is empty</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-max" class="anchored"><a href="#val-max" class="anchor"></a><code><span><span class="keyword">val</span> max : <span>?lt:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Maximum element, see <a href="#val-min"><code>min</code></a></p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the generator is empty</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-eq" class="anchored"><a href="#val-eq" class="anchor"></a><code><span><span class="keyword">val</span> eq : <span>?eq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Equality of generators.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lexico" class="anchored"><a href="#val-lexico" class="anchor"></a><code><span><span class="keyword">val</span> lexico : <span>?cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Lexicographic comparison of generators. If a generator is a prefix of the other one, it is considered smaller.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span>?cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Synonym for <a href="#val-lexico"><code>lexico</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find p e</code> returns the first element of <code>e</code> to satisfy <code>p</code>, or None.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sum" class="anchored"><a href="#val-sum" class="anchor"></a><code><span><span class="keyword">val</span> sum : <span><span>int <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Sum of all elements</p></div></div><h3 id="multiple-iterators"><a href="#multiple-iterators" class="anchor"></a>Multiple iterators</h3><div class="odoc-spec"><div class="spec value" id="val-map2" class="anchored"><a href="#val-map2" class="anchor"></a><code><span><span class="keyword">val</span> map2 : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Map on the two sequences. Stops once one of them is exhausted.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter2" class="anchored"><a href="#val-iter2" class="anchor"></a><code><span><span class="keyword">val</span> iter2 : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Iterate on the two sequences. Stops once one of them is exhausted.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold2" class="anchored"><a href="#val-fold2" class="anchor"></a><code><span><span class="keyword">val</span> fold2 : <span><span>( <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p>Fold the common prefix of the two iterators</p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all2" class="anchored"><a href="#val-for_all2" class="anchor"></a><code><span><span class="keyword">val</span> for_all2 : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Succeeds if all pairs of elements satisfy the predicate. Ignores elements of an iterator if the other runs dry.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists2" class="anchored"><a href="#val-exists2" class="anchor"></a><code><span><span class="keyword">val</span> exists2 : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Succeeds if some pair of elements satisfy the predicate. Ignores elements of an iterator if the other runs dry.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zip_with" class="anchored"><a href="#val-zip_with" class="anchor"></a><code><span><span class="keyword">val</span> zip_with : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Combine common part of the gens (stops when one is exhausted)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zip" class="anchored"><a href="#val-zip" class="anchor"></a><code><span><span class="keyword">val</span> zip : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Zip together the common part of the gens</p></div></div><h3 id="complex-combinators"><a href="#complex-combinators" class="anchor"></a>Complex combinators</h3><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><span><span><span class="type-var">'a</span> <a href="../Gen_intf/index.html#type-gen">Gen_intf.gen</a></span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Pick elements fairly in each sub-generator. The merge of gens <code>e1, e2, ... </code> picks elements in <code>e1</code>, <code>e2</code>, in <code>e3</code>, <code>e1</code>, <code>e2</code> .... Once a generator is empty, it is skipped; when they are all empty, and none remains in the input, their merge is also empty. For instance, <code>merge [1;3;5] [2;4;6]</code> will be, in disorder, <code>1;2;3;4;5;6</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-intersection" class="anchored"><a href="#val-intersection" class="anchor"></a><code><span><span class="keyword">val</span> intersection : <span>?cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Intersection of two sorted sequences. Only elements that occur in both inputs appear in the output</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sorted_merge" class="anchored"><a href="#val-sorted_merge" class="anchor"></a><code><span><span class="keyword">val</span> sorted_merge : <span>?cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Merge two sorted sequences into a sorted sequence</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sorted_merge_n" class="anchored"><a href="#val-sorted_merge_n" class="anchor"></a><code><span><span class="keyword">val</span> sorted_merge_n : <span>?cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Sorted merge of multiple sorted sequences</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tee" class="anchored"><a href="#val-tee" class="anchor"></a><code><span><span class="keyword">val</span> tee : <span>?n:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Gen_intf/index.html#type-gen">Gen_intf.gen</a></span> list</span></span></code></div><div class="spec-doc"><p>Duplicate the gen into <code>n</code> generators (default 2). The generators share the same underlying instance of the gen, so the optimal case is when they are consumed evenly</p></div></div><div class="odoc-spec"><div class="spec value" id="val-round_robin" class="anchored"><a href="#val-round_robin" class="anchor"></a><code><span><span class="keyword">val</span> round_robin : <span>?n:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Gen_intf/index.html#type-gen">Gen_intf.gen</a></span> list</span></span></code></div><div class="spec-doc"><p>Split the gen into <code>n</code> generators in a fair way. Elements with <code>index = k mod n</code> with go to the k-th gen. <code>n</code> default value is 2.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interleave" class="anchored"><a href="#val-interleave" class="anchor"></a><code><span><span class="keyword">val</span> interleave : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p><code>interleave a b</code> yields an element of <code>a</code>, then an element of <code>b</code>, and so on. When a generator is exhausted, this behaves like the other generator.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-intersperse" class="anchored"><a href="#val-intersperse" class="anchor"></a><code><span><span class="keyword">val</span> intersperse : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Put the separator element between all elements of the given gen</p></div></div><div class="odoc-spec"><div class="spec value" id="val-product" class="anchored"><a href="#val-product" class="anchor"></a><code><span><span class="keyword">val</span> product : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Cartesian product, in no predictable order. Works even if some of the arguments are infinite.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-group" class="anchored"><a href="#val-group" class="anchor"></a><code><span><span class="keyword">val</span> group : <span>?eq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Group equal consecutive elements together.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uniq" class="anchored"><a href="#val-uniq" class="anchor"></a><code><span><span class="keyword">val</span> uniq : <span>?eq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Remove consecutive duplicate elements. Basically this is like <code>fun e -&gt; map List.hd (group e)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sort" class="anchored"><a href="#val-sort" class="anchor"></a><code><span><span class="keyword">val</span> sort : <span>?cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Sort according to the given comparison function. The gen must be finite.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sort_uniq" class="anchored"><a href="#val-sort_uniq" class="anchor"></a><code><span><span class="keyword">val</span> sort_uniq : <span>?cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Sort and remove duplicates. The gen must be finite.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-chunks" class="anchored"><a href="#val-chunks" class="anchor"></a><code><span><span class="keyword">val</span> chunks : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p><code>chunks n e</code> returns a generator of arrays of length <code>n</code>, composed of successive elements of <code>e</code>. The last array may be smaller than <code>n</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-permutations" class="anchored"><a href="#val-permutations" class="anchor"></a><code><span><span class="keyword">val</span> permutations : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Permutations of the gen.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-permutations_heap" class="anchored"><a href="#val-permutations_heap" class="anchor"></a><code><span><span class="keyword">val</span> permutations_heap : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Permutations of the gen, using Heap's algorithm.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-combinations" class="anchored"><a href="#val-combinations" class="anchor"></a><code><span><span class="keyword">val</span> combinations : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Combinations of given length. The ordering of the elements within each combination is unspecified. Example (ignoring ordering): <code>combinations 2 (1--3) |&gt; to_list = [[1;2]; [1;3]; [2;3]]</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-power_set" class="anchored"><a href="#val-power_set" class="anchor"></a><code><span><span class="keyword">val</span> power_set : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>All subsets of the gen (in no particular order). The ordering of the elements within each subset is unspecified.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2.2</li></ul></div></div><h3 id="basic-conversion-functions"><a href="#basic-conversion-functions" class="anchor"></a>Basic conversion functions</h3><div class="odoc-spec"><div class="spec value" id="val-of_list" class="anchored"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Enumerate elements of the list</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_list" class="anchored"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>non tail-call trasnformation to list, in the same order</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_rev_list" class="anchored"><a href="#val-to_rev_list" class="anchor"></a><code><span><span class="keyword">val</span> to_rev_list : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Tail call conversion to list, in reverse order (more efficient)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_array" class="anchored"><a href="#val-to_array" class="anchor"></a><code><span><span class="keyword">val</span> to_array : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p>Convert the gen to an array (not very efficient)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_array" class="anchored"><a href="#val-of_array" class="anchor"></a><code><span><span class="keyword">val</span> of_array : <span>?start:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Iterate on (a slice of) the given array</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>?start:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Iterate on bytes of the string</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><span>char <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Convert into a string</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_buffer" class="anchored"><a href="#val-to_buffer" class="anchor"></a><code><span><span class="keyword">val</span> to_buffer : <span><span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span><span>char <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Consumes the iterator and writes to the buffer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rand_int" class="anchored"><a href="#val-rand_int" class="anchor"></a><code><span><span class="keyword">val</span> rand_int : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Random ints in the given range.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int_range" class="anchored"><a href="#val-int_range" class="anchor"></a><code><span><span class="keyword">val</span> int_range : <span>?step:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p><code>int_range ~step a b</code> generates integers between <code>a</code> and <code>b</code>, included, with steps of length <code>step</code> (1 if omitted). <code>a</code> is assumed to be smaller than <code>b</code>, otherwise the result will be empty.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>step=0</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">step</span> <p>step between two numbers; must not be zero, but it can be negative for decreasing ranges (@since 0.5).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-lines" class="anchored"><a href="#val-lines" class="anchor"></a><code><span><span class="keyword">val</span> lines : <span><span>char <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Group together chars belonging to the same line</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-unlines" class="anchored"><a href="#val-unlines" class="anchor"></a><code><span><span class="keyword">val</span> unlines : <span><span>string <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Explode lines into their chars, adding a <code>'\n'</code> after each one</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.3</li></ul></div></div><div class="odoc-spec"><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Infix/index.html">Infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(--)" class="anchored"><a href="#val-(--)" class="anchor"></a><code><span><span class="keyword">val</span> (--) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Synonym for <code> int_range ~by:1</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Gen_intf/index.html#type-gen">Gen_intf.gen</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Monadic bind operator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;|) : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Infix map operator</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;|=)" class="anchored"><a href="#val-(&gt;|=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;|=) : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Infix map operator</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : 
  <span>?start:string <span class="arrow">&#45;&gt;</span></span>
  <span>?stop:string <span class="arrow">&#45;&gt;</span></span>
  <span>?sep:string <span class="arrow">&#45;&gt;</span></span>
  <span>?horizontal:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Pretty print the content of the generator on a formatter.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq" class="anchored"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_iter" class="anchored"><a href="#val-to_iter" class="anchor"></a><code><span><span class="keyword">val</span> to_iter : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Gen_intf/index.html#type-iter">Gen_intf.iter</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.0</li></ul></div></div></details></div><h3 id="restartable-generators"><a href="#restartable-generators" class="anchor"></a>Restartable generators</h3><p>A <i>restartable generator</i> is a function that produces copies of the same generator, on demand. It has the type <code>unit -&gt; 'a gen</code> and it is assumed that every generated returned by the function behaves the same (that is, that it traverses the same sequence of elements).</p><div class="odoc-spec"><div class="spec module" id="module-Restart" class="anchored"><a href="#module-Restart" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Restart/index.html">Restart</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="utils"><a href="#utils" class="anchor"></a>Utils</h3><div class="odoc-spec"><div class="spec value" id="val-persistent" class="anchored"><a href="#val-persistent" class="anchor"></a><code><span><span class="keyword">val</span> persistent : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="Restart/index.html#type-t">Restart.t</a></span></span></code></div><div class="spec-doc"><p>Store content of the transient generator in memory, to be able to iterate on it several times later. If possible, consider using combinators from <a href="Restart/index.html"><code>Restart</code></a> directly instead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-persistent_lazy" class="anchored"><a href="#val-persistent_lazy" class="anchor"></a><code><span><span class="keyword">val</span> persistent_lazy : 
  <span>?caching:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?max_chunk_size:int <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="Restart/index.html#type-t">Restart.t</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-persistent"><code>persistent</code></a>, but consumes the generator on demand (by chunks). This allows to make a restartable generator out of an ephemeral one, without paying a big cost upfront (nor even consuming it fully). Optional parameters: see <a href="../GenMList/index.html#val-of_gen_lazy"><code>GenMList.of_gen_lazy</code></a>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-persistent_to_seq" class="anchored"><a href="#val-persistent_to_seq" class="anchor"></a><code><span><span class="keyword">val</span> persistent_to_seq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-persistent"><code>persistent</code></a>, but returns a standard Seq.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-persistent_lazy_to_seq" class="anchored"><a href="#val-persistent_lazy_to_seq" class="anchor"></a><code><span><span class="keyword">val</span> persistent_lazy_to_seq : 
  <span>?caching:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?max_chunk_size:int <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-persistent_lazy"><code>persistent_lazy</code></a>, but returns a standard Seq.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'a</span> option</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>peek g</code> transforms the generator <code>g</code> into a generator of <code>x, Some next</code> if <code>x</code> was followed by <code>next</code> in <code>g</code>, or <code>x, None</code> if <code>x</code> was the last element of <code>g</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-peek_n" class="anchored"><a href="#val-peek_n" class="anchor"></a><code><span><span class="keyword">val</span> peek_n : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'a</span> array</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>peek_n n g</code> iterates on <code>g</code>, returning along with each element the array of the (at most) <code>n</code> elements that follow it immediately</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the int is <code>&lt; 1</code></p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-start" class="anchored"><a href="#val-start" class="anchor"></a><code><span><span class="keyword">val</span> start : <span><span><span class="type-var">'a</span> <a href="Restart/index.html#type-t">Restart.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Create a new transient generator. <code>start gen</code> is the same as <code>gen ()</code> but is included for readability.</p></div></div><h3 id="basic-io"><a href="#basic-io" class="anchor"></a>Basic IO</h3><p>Very basic interface to manipulate files as sequence of chunks/lines.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2.3</li></ul><div class="odoc-spec"><div class="spec module" id="module-IO" class="anchored"><a href="#module-IO" class="anchor"></a><code><span><span class="keyword">module</span> <a href="IO/index.html">IO</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>